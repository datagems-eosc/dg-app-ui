#!/bin/bash
# Generates public/__env.js with PUBLIC_* variables for browser access
set -e

echo -e "\nenv.sh: Generating runtime environment..."

ENVSH_PREFIX="${ENVSH_PREFIX:-"PUBLIC_"}"
ENVSH_OUTPUT="${ENVSH_OUTPUT:-"./public/__env.js"}"
ENVSH_VERBOSE="${ENVSH_VERBOSE:-false}"

__green() { printf '\033[1;32m%b\033[0m' "$1"; }
__yellow() { printf '\033[1;33m%b\033[0m' "$1"; }
__info() { printf "%s\n" "$1"; }

# Load defaults, then .env files (later sources override earlier)
[ -f "./env.defaults.sh" ] && { set -a; source ./env.defaults.sh; set +a; }
[ -n "$NODE_ENV" ] && [ -f ".env.${NODE_ENV}" ] && { set -a; source ".env.${NODE_ENV}"; set +a; } || \
[ -f .env.local ] && { set -a; source .env.local; set +a; } || \
[ -f .env ] && { set -a; source .env; set +a; }

mkdir -p "$(dirname "$ENVSH_OUTPUT")"
matched_envs=$(env | grep "^${ENVSH_PREFIX}" || true)

# Generate __env.js
echo "// Auto-generated by env.sh at $(date -u +"%Y-%m-%dT%H:%M:%SZ")" > "$ENVSH_OUTPUT"
echo "window.__env = {" >> "$ENVSH_OUTPUT"

if [ -n "$matched_envs" ]; then
  __info "PUBLIC_* variables:"
  while IFS= read -r matched_env; do
    key="${matched_env%%=*}"
    value="${matched_env#*=}"
    __info "   - $key"
    escaped_value=$(echo "$value" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g')
    echo "  \"$key\": \"$escaped_value\"," >> "$ENVSH_OUTPUT"
  done <<< "$matched_envs"
else
  __info "$(__yellow "Warning: No PUBLIC_* variables found")"
fi

echo "};" >> "$ENVSH_OUTPUT"
__info "$(__green "Generated $ENVSH_OUTPUT")"

exec "$@"
